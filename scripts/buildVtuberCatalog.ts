import dotenv from 'dotenv'
import fs from 'fs/promises'
import path from 'path'
import { frVtubersTeamMembers } from '../src/data/generated/frvtubersTeam'

dotenv.config()

type FetchResponse = {
  ok: boolean
  status: number
  json(): Promise<any>
  text(): Promise<string>
}

type FetchLike = (input: string, init?: any) => Promise<FetchResponse>

const ensureFetch = (): FetchLike => {
  const fn = (globalThis as any).fetch as FetchLike | undefined
  if (!fn) {
    throw new Error(
      'Global fetch API is not available. Please use Node.js >= 18 to run this script.',
    )
  }
  return fn
}

const fetchFn = ensureFetch()

type SearchActorsResponse = {
  actors: ActorProfile[]
  cursor?: string
}

type ActorProfile = {
  did: string
  handle: string
  displayName?: string
  description?: string
}

type VtuberProfile = {
  did: string
  handle: string
  displayName?: string
  description?: string
  score: number
  matchedTerms: string[]
  twitchLogin?: string
  isFrVtubersTeam: boolean
}

const searchTerms = [
  'vtuberfr',
  'frvtuber',
  'fr vtuber',
  'vtuber fr',
  'vtubeur fr',
  'vtubeuse fr',
  'vtubeur',
  'vtubeuse',
  'frvtubers',
  '#frvtuber',
  '#vtuberfr',
  'vtuberqc',
  'qcvtuber',
  'vtbfr',
  'vtubing',
  'vtubbing',
] as const

const detectionKeywords = [
  ...searchTerms,
  'vtb',
  'vtuber français',
  'vtuber francaise',
  'vtuber française',
  '#vtbfr',
  '#vtuberqc',
  '#qcvtuber',
] as const

const twitchTeamLogins = new Set(
  (frVtubersTeamMembers ?? []).map((member) =>
    member.userLogin.toLowerCase(),
  ),
)

const main = async () => {
  const profiles = await gatherVtuberProfiles()
  const generatedAt = new Date().toISOString()

  const fileHeader = `// Auto-generated by scripts/buildVtuberCatalog.ts on ${generatedAt}\n// Do not edit manually.\n\n`
  const interfaceBlock = `export interface GeneratedVtuberProfile {\n  did: string\n  handle: string\n  displayName?: string\n  description?: string\n  score: number\n  matchedTerms: string[]\n  twitchLogin?: string\n  isFrVtubersTeam: boolean\n}\n\n`
  const timestampExport = `export const vtuberCatalogGeneratedAt = '${generatedAt}'\n\n`
  const catalogExport = `export const vtuberCatalog: GeneratedVtuberProfile[] = ${JSON.stringify(
    profiles,
    null,
    2,
  )} as const\n`

  const output = `${fileHeader}${interfaceBlock}${timestampExport}${catalogExport}`

  const outputPath = path.resolve(
    __dirname,
    '../src/data/generated/vtuberCatalog.ts',
  )

  await fs.mkdir(path.dirname(outputPath), { recursive: true })
  await fs.writeFile(outputPath, output, 'utf8')

  console.log(
    `Wrote ${profiles.length} vtuber profiles to src/data/generated/vtuberCatalog.ts`,
  )
}

const gatherVtuberProfiles = async (): Promise<VtuberProfile[]> => {
  const map = new Map<string, VtuberProfile>()

  for (const rawTerm of searchTerms) {
    const term = rawTerm.trim()
    if (!term) continue

    const response = await searchActors(term)
    if (!response) continue

    for (const actor of response.actors) {
      if (!actor?.did || !actor.handle) continue

      const profileText = buildProfileText(actor)
      const matchedTerms = new Set<string>()

      matchedTerms.add(term.toLowerCase())

      for (const keyword of detectionKeywords) {
        if (
          keyword &&
          profileText.includes(keyword.toLowerCase()) &&
          !matchedTerms.has(keyword.toLowerCase())
        ) {
          matchedTerms.add(keyword.toLowerCase())
        }
      }

      if (matchedTerms.size === 0) continue

      const twitchLogin = extractTwitchLogin(actor.description)
      const mentionsTeam = profileText.includes('team frvtubers')
        || profileText.includes('frvtubers team')
        || profileText.includes('#teamfrvtubers')
      const isTeam = twitchLogin
        ? twitchTeamLogins.has(twitchLogin.toLowerCase()) || mentionsTeam
        : mentionsTeam

      const existing = map.get(actor.did)
      if (existing) {
        const mergedTerms = new Set([
          ...existing.matchedTerms.map((item) => item.toLowerCase()),
          ...matchedTerms,
        ])
        const mergedScore = Math.max(mergedTerms.size, existing.score, 1)
        map.set(actor.did, {
          ...existing,
          displayName: actor.displayName ?? existing.displayName,
          description: actor.description ?? existing.description,
          matchedTerms: Array.from(mergedTerms),
          score: mergedScore,
          twitchLogin: existing.twitchLogin ?? twitchLogin,
          isFrVtubersTeam: existing.isFrVtubersTeam || isTeam,
        })
        continue
      }

      map.set(actor.did, {
        did: actor.did,
        handle: actor.handle,
        displayName: actor.displayName,
        description: actor.description,
        score: Math.max(matchedTerms.size, 1),
        matchedTerms: Array.from(matchedTerms),
        twitchLogin,
        isFrVtubersTeam: isTeam,
      })
    }
  }

  const catalog = Array.from(map.values())
  catalog.sort((a, b) => {
    if (b.isFrVtubersTeam !== a.isFrVtubersTeam) {
      return Number(b.isFrVtubersTeam) - Number(a.isFrVtubersTeam)
    }
    if (b.score !== a.score) return b.score - a.score
    return a.handle.localeCompare(b.handle)
  })

  return catalog
}

const buildProfileText = (actor: ActorProfile): string => {
  return [
    actor.handle ?? '',
    actor.displayName ?? '',
    actor.description ?? '',
  ]
    .join(' ')
    .toLowerCase()
}

const searchActors = async (
  term: string,
): Promise<SearchActorsResponse | undefined> => {
  const url = new URL(
    'https://public.api.bsky.app/xrpc/app.bsky.actor.searchActors',
  )
  url.searchParams.set('term', term)
  url.searchParams.set('limit', '100')

  const response = await fetchFn(url.toString())
  if (!response.ok) {
    const body = await response.text()
    console.warn(
      `Failed to fetch actors for term "${term}" (${response.status}): ${body}`,
    )
    return undefined
  }

  return (await response.json()) as SearchActorsResponse
}

const extractTwitchLogin = (description?: string): string | undefined => {
  if (!description) return undefined
  const regex = /twitch\.tv\/([a-z0-9_]+)/gi
  const matches = Array.from(description.matchAll(regex))
  if (matches.length === 0) return undefined
  return matches[0][1]
}

main().catch((err) => {
  console.error(err)
  process.exit(1)
})
